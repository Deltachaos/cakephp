<?php
declare(strict_types=1);

/**
 * CakePHP(tm) : Rapid Development Framework (https://cakephp.org)
 * Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
 *
 * Licensed under The MIT License
 * For full copyright and license information, please see the LICENSE.txt
 * Redistributions of files must retain the above copyright notice.
 *
 * @copyright     Copyright (c) Cake Software Foundation, Inc. (https://cakefoundation.org)
 * @link          https://cakephp.org CakePHP(tm) Project
 * @since         5.1.0
 * @license       https://opensource.org/licenses/mit-license.php MIT License
 */
namespace Cake\Core;

use Cake\Utility\Hash;

/**
 * PluginConfig contains all available plugins and their config if/how they should be loaded
 *
 * @link https://book.cakephp.org/5/en/plugins.html
 */
class PluginConfig
{
    /**
     * Constructor
     */
    public function __construct()
    {
        $this->loadConfig();
    }

    /**
     * Load the path information stored in vendor/cakephp-plugins.php
     *
     * This file is generated by the cakephp/plugin-installer package and used
     * to locate plugins on the filesystem as applications can use `extra.plugin-paths`
     * in their composer.json file to move plugin outside of vendor/
     *
     * @internal
     * @return void
     */
    protected function loadConfig(): void
    {
        if (Configure::check('plugins')) {
            return;
        }
        $vendorFile = dirname(__DIR__, 2) . DIRECTORY_SEPARATOR . 'cakephp-plugins.php';
        if (!is_file($vendorFile)) {
            $vendorFile = dirname(__DIR__, 4) . DIRECTORY_SEPARATOR . 'cakephp-plugins.php';
            if (!is_file($vendorFile)) {
                Configure::write(['plugins' => []]);

                return;
            }
        }

        $config = require $vendorFile;
        Configure::write($config);
    }

    /**
     * Get the config how plugins should be loaded
     *
     * @return array
     */
    public function getConfig(): array
    {
        // Make sure to load the current state of available plugins
        Configure::delete('plugins');
        Plugin::getCollection()->clear();
        $this->loadConfig();

        // phpcs:ignore
        $pluginLoadConfig = @include CONFIG . 'plugins.php';
        if (is_array($pluginLoadConfig)) {
            $pluginLoadConfig = Hash::normalize($pluginLoadConfig);
        }

        $result = [];
        $availablePlugins = Configure::read('plugins', []);
        if ($availablePlugins && is_array($availablePlugins)) {
            $availablePlugins = array_keys($availablePlugins);
            foreach ($availablePlugins as $pluginName) {
                if ($pluginLoadConfig && array_key_exists($pluginName, $pluginLoadConfig)) {
                    $options = $pluginLoadConfig[$pluginName];
                    $hooks = PluginInterface::VALID_HOOKS;
                    $mainConfig = [
                        'isActive' => true,
                        'onlyDebug' => $options['onlyDebug'] ?? false,
                        'onlyCli' => $options['onlyCli'] ?? false,
                        'optional' => $options['optional'] ?? false,
                    ];
                    foreach ($hooks as $hook) {
                        $mainConfig[$hook] = $options[$hook] ?? true;
                    }
                    $result[$pluginName] = $mainConfig;
                } else {
                    $result[$pluginName]['isActive'] = false;
                }
            }
        }

        return $result;
    }
}
